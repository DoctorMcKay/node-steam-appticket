const ChildProcess = require('child_process');
const FS = require('fs');
const Path = require('path');

const PBJS_BINARY_PATH = Path.resolve(__dirname, '..', 'node_modules', 'protobufjs-cli', 'bin', 'pbjs');
const PROTO_FILE_PATH = Path.resolve(__dirname, '..', 'protobufs', '%s.proto');
const PBJS_COMMAND_LINE = `node "${PBJS_BINARY_PATH}" --target json --keep-case "${PROTO_FILE_PATH}"`;
const GENERATED_DIR = Path.resolve(__dirname, '..', 'src', 'protobuf-generated');

const OVERRIDE_TYPEDEF_TYPES = {};

const GENERATED_FILE_HEADER = `/* eslint-disable */\n// Auto-generated by generate-protos script on ${(new Date()).toString()}\n\n`;

let loader = GENERATED_FILE_HEADER;
loader += "import Protobuf from 'protobufjs';\nimport type {Type as ProtoType} from 'protobufjs';\nconst Schema:{[name: string]: ProtoType} = {};\n\n";

if (!FS.existsSync(GENERATED_DIR)) {
	FS.mkdirSync(GENERATED_DIR);
}

// First we want to delete the contents of the generated dir
FS.readdirSync(GENERATED_DIR).forEach((filename) => {
	console.log(`Delete ${filename}`);
	FS.unlinkSync(Path.join(GENERATED_DIR, filename));
});

let typesFile = FS.openSync(Path.join(GENERATED_DIR, 'types.ts'), 'w');
let documentedTypes = {}; // Some types might be defined in multiple proto files. Let's only include each type once.

FS.writeSync(typesFile, GENERATED_FILE_HEADER);

let loaderMerges = '';

FS.readdirSync(Path.join(__dirname, '..', 'protobufs')).forEach((filename) => {
	if (!filename.match(/\.proto$/)) {
		return;
	}

	let filenameWithoutExtension = filename.replace('.proto', '');
	let safeFilename = filenameWithoutExtension.replace(/\./g, '_');
	let cmdLine = PBJS_COMMAND_LINE.replace(/%s/g, filenameWithoutExtension);
	console.log(cmdLine);

	let protoDefinition = JSON.parse(ChildProcess.execSync(cmdLine).toString('utf8'));
	loader += `const ${safeFilename}:any = ${JSON.stringify(protoDefinition)};\n`;
	loaderMerges += `Object.assign(Schema, Protobuf.Root.fromJSON(${safeFilename}));\n`;

	if (protoDefinition.nested) {
		FS.writeSync(typesFile, `///////////////////////////////////////////////\n// ${filenameWithoutExtension}.proto\n///////////////////////////////////////////////\n\n`);
		FS.writeSync(typesFile, writeTypedef(protoDefinition.nested));
	}
});

FS.closeSync(typesFile);

console.log("Generating load.ts");
loader += `\n${loaderMerges}\nexport default Schema;\n`;
FS.writeFileSync(GENERATED_DIR + '/load.ts', loader);

function writeTypedef(obj, namespace = '.') {
	let output = '';

	for (let i in obj) {
		// skip options and nested messages
		if (i == 'options' || i == 'nested' || i == 'google' || obj[i].type) {
			continue;
		}

		if (documentedTypes[namespace + i]) {
			// We already documented this type
			continue;
		}

		documentedTypes[namespace + i] = true;

		let resolvedName = (namespace + i)
			.replace(/^\./, '')
			.replace(/\./g, '_');

		if (obj[i].values) {
			// This is an enum. We want to skip it only if it's present in the root namespace
			if (namespace == '.') {
				continue;
			}

			output += `export enum ${resolvedName} {\n`;
			for (let j in obj[i].values) {
				output += `\t${j} = ${obj[i].values[j]},\n`;
			}
		} else {
			// This is a message
			output += `export interface ${resolvedName} {\n`;
			for (let j in obj[i].fields) {
				let type = protobufTypeToJsType(obj[i].fields[j].type);
				let name = j;

				if (type == 'number' && ['eresult', 'eResult', 'result'].includes(name)) {
					type = 'EResult';
				}

				if (OVERRIDE_TYPEDEF_TYPES[resolvedName] && OVERRIDE_TYPEDEF_TYPES[resolvedName][j]) {
					type = OVERRIDE_TYPEDEF_TYPES[resolvedName][j];
				}

				let optionalMark = '';

				switch (obj[i].fields[j].rule) {
					case 'repeated':
						optionalMark = '?';
						type += '[]';
						break;

					case 'required':
						break;

					default:
						optionalMark = '?';
				}

				output += `\t${name}${optionalMark}: ${type};\n`;
			}
		}

		output += '}\n\n';

		// Do we have nested messages?
		if (obj[i].nested) {
			output += writeTypedef(obj[i].nested, namespace + i + '.');
		}
	}

	return output;

	function protobufTypeToJsType(type) {
		switch (type) {
			case 'double':
			case 'float':
			case 'int32':
			case 'uint32':
			case 'sint32':
			case 'fixed32':
			case 'sfixed32':
				return 'number';

			case 'int64':
			case 'uint64':
			case 'sint64':
			case 'fixed64':
			case 'sfixed64':
				// 64-bit numbers are represented as strings
				return 'string';

			case 'bool':
				return 'boolean';

			case 'string':
				return 'string';

			case 'bytes':
				return 'Buffer';

			default:
				if (type[0] == '.') {
					// It's another protobuf msg, or an enum
					if (type[1] == 'E') {
						// It's an enum
						return type.substring(1);
					}

					return type
						.replace(/^\./, '')
						.replace(/\./g, '_');
				}

				throw new Error(`Unknown protobuf type ${type}`);
		}
	}
}
